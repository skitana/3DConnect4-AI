(defun stampajOznake (n)
    (dotimes (k n)
                 (format t "~d " (nth k oznake))
      )
  )

(defun napraviListu (array)
  (let* ((dimensions (array-dimensions array))
           (depth      (1- (length dimensions)))
           (indices    (make-list (1+ depth) :initial-element 0))
         )
    (labels ((recurse (n)
               (loop for j below (nth n dimensions)
                     do (setf (nth n indices) j)
                     collect (if (= n depth)
                                 (apply #'aref array indices)
                                 (recurse (1+ n)))
                  )
               ))
        (recurse 0)
      )
    )
  )
 (defvar gore)(defvar dole)(defvar counter)
(defun stampaj (n lista)
 
  (dotimes (k (- (* n 2) 1))
    (setf gore (- n(+ k 1)))
    (setf dole (- (+ k 1) n))
    (if(>= k n)
        (setf counter (- n dole))
        (setf counter (- n gore))
      )
    (dotimes (i n)
      (if(< k n)
      (dotimes (j gore)
         (format t "  ")
        ))
      (dotimes (j counter)
          (format t "~d " (nth (- n (+ j 1))(nth (- n (- counter j))(nth i lista))))
        )
      (if(>= k n)
      (dotimes (j dole)
         (format t "  ")
        ))
      )
    (fresh-line)
    )
  )
  
(defun blankSpaces (n)
     (if(= n 5)
        (format t "  ")
      )
    (if(= n 6)
        (format t "    ")
      )  
    ) 
(defun printOldie (n lista)
  
  (dotimes (z n)  
    (blankSpaces n)
      (format t "      ~d " (nth (- n 1)(nth (- n 1)(nth z lista))))
    )(fresh-line)
  
  (dotimes (z n)
     (blankSpaces n)
    (format t "    ~d ~d " (nth (- n 1)(nth (- n 2)(nth z lista)))
                           (nth (- n 2)(nth (- n 1)(nth z lista)))
      )
    )(fresh-line)
  
  (dotimes (z n)
    (blankSpaces n)
    (format t "  ~d ~d ~d " (nth (- n 1)(nth (- n 3)(nth z lista)))
                            (nth (- n 2)(nth (- n 2)(nth z lista)))
                            (nth (- n 3)(nth (- n 1)(nth z lista)))
      )
    )(fresh-line) 
  
  (dotimes (z n)
     (blankSpaces n)
    (format t "~d ~d ~d ~d " (nth (- n 1)(nth (- n 4)(nth z lista)))
                             (nth (- n 2)(nth (- n 3)(nth z lista)))
                             (nth (- n 3)(nth (- n 2)(nth z lista)))
                             (nth (- n 4)(nth (- n 1)(nth z lista)))
      )
    )(fresh-line) 
  
  (if(> n 4)
   ((lambda (n lista)   
   (dotimes (z n)
     (if(> n 5)(format t "  "))   
     (format t "~d ~d ~d ~d ~d " (nth (- n 1)(nth (- n 5)(nth z lista)))
                             (nth (- n 2)(nth (- n 4)(nth z lista)))
                             (nth (- n 3)(nth (- n 3)(nth z lista)))
                             (nth (- n 4)(nth (- n 2)(nth z lista)))
                             (nth (- n 5)(nth (- n 1)(nth z lista)))
       )
     )(fresh-line) 
    )n lista))
  
  (if(> n 5)
  ((lambda (n lista)
   (dotimes (z n)  
     (format t "~d ~d ~d ~d ~d ~d " (nth 5 (nth 0 (nth z lista)))
                             (nth 4 (nth 1 (nth z lista)))
                             (nth 3 (nth 2 (nth z lista)))
                             (nth 2 (nth 3 (nth z lista)))
                             (nth 1 (nth 4 (nth z lista)))       
                             (nth 0 (nth 5 (nth z lista)))
         )
     )(fresh-line) 
    (dotimes (z n)   
     (format t "~d ~d ~d ~d ~d   " (nth 4 (nth 0 (nth z lista)))
                             (nth 3 (nth 1 (nth z lista)))
                             (nth 2 (nth 2 (nth z lista)))
                             (nth 1 (nth 3 (nth z lista)))
                             (nth 0 (nth 4 (nth z lista)))
       )
     )(fresh-line) 
    )n lista))
  (if(> n 4)
   ((lambda (n lista)   
   (dotimes (z n)  
     (format t "~d ~d ~d ~d " (nth 3 (nth 0 (nth z lista)))
                             (nth 2 (nth 1 (nth z lista)))
                             (nth 1 (nth 2 (nth z lista)))
                             (nth 0 (nth 3 (nth z lista)))
       )
     (blankSpaces n)
     )(fresh-line) 
   )n lista))
  (dotimes (z n)
    (format t "~d ~d ~d   " (nth 2 (nth 0 (nth z lista)))
                            (nth 1 (nth 1(nth z lista)))
                            (nth 0 (nth 2(nth z lista)))
      )
     (blankSpaces n)
    )(fresh-line)
  
  (dotimes (z n)
    (format t "~d ~d     " (nth 1 (nth 0 (nth z lista)))
                           (nth 0 (nth 1 (nth z lista)))
      )
     (blankSpaces n)
    )(fresh-line) 
  
  (dotimes (z n)
    (format t "~d       " (nth 0 (nth 0 (nth z lista))))
     (blankSpaces n)
    )(fresh-line)
 
)

(defun refresh (n lista)
  
  (dotimes (k (* n n))
      (format t "~d " (nth k oznake))
    )
  (fresh-line)
  (printOldie n lista)
  ;(stampaj n lista)
  
  (dotimes (k (* n n))
      (format t "~d " (nth k oznake))
    )
  (fresh-line)
  )

(defun upisiPotez (i j pom lista)
  (setf (nth pom(nth j(nth i lista))) tip)
  (incf brojPoteza)
  )

(defun upisi (i j pom lista)
  (if(eq (nth pom (nth j (nth i lista))) '-) (upisiPotez i j pom lista)
    (upisi i j (+ 1 pom) lista)
    )
 )
(defun sracunaj (n)
  (refresh n lista)
  ;(format t "Igra formata ~d je zavrsena." n)(fresh-line)
  (cond   ((< pts2 pts1)    (format t "Pobednik je ~d. Rezultat je ~d:~d" prvi pts1 pts2))
        ((> pts2 pts1)    (format t "Pobednik je ~d. Rezultat je ~d:~d" drugi pts1 pts2))
        ((= pts2 pts1) (format t "Igra je zavrsena nereseno rezultatom ~d:~d" pts1 pts2))
        )
  (fresh-line)
  (format t "Zelite da nastavite igru?")(fresh-line)
  (if(equal (read) 'da)(potez n lista))
    )
(defun provera (i j n lista)      
  ;;(format t "~d ~d~%" i j)
  (if(or (> i (- n 1)) (> j (- n 1))) (potez n lista))
  (if(eq (nth (- (length lista) 1) (nth j(nth i lista))) '-) (upisi i j 0 lista)   (potez n lista))
  (if (eq tip 'x) (setf tip 'o)(setf tip 'x))
  ;;odredjivanje mogucih stanja
  (setq mogucaStanja '())
  (stanja 0 lista)
  (if(>= brojPoteza (* n n n))
      ((lambda (n lista)
         ;(sracunaj n)
         (kraj 0 lista)
         ;(exit)
         )n lista)
       ;;else
      (potez n lista))
  )

(defun potez (n lista)
    (refresh n lista)
    ;((potez (read)(read)) ((princ (format t "~d ~d~d~%" "Potez" tip ":")) ))
  (format t "~d ~d~d~%" "Potez" tip ":")
  (setq arg1 (read))  
  (if(equal arg1 'stanje)(kraj 0 lista))
  (provera arg1 (read) (length lista) lista)
  )

(defun start (n)
  (setq oznake '(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z))
  (setf tip 'x)
  (princ "1st player: " )(setq prvi (read))
  (princ "2nd player: " )(setq drugi (read))
  (setq brojPoteza 0)
  (setq pts1 0)
  (setq pts2 0)
  (defparameter niz
     (make-array (list n n n)
         :element-type 'char
         :initial-element '-)
       )
  (setq lista(napraviListu niz))
     
   ;(refresh n)
  (potez n lista)
  ;(makunbound lista)
  )
(defun proveriNavise (n rez)
         (if(equal '() (remove 'x (nth n rez)))(incf pts1)                                           
           (if(equal '()  (remove 'o (nth n rez)))(incf pts2)))       
  (if(< (+ 1 n) (length rez))(proveriNavise (+ n 1) rez))
  )
(setq horiz '(()()()()))
(defun proveriHoriz (i j k lista)
  (cond
   ((< j (length lista))
    (setf (nth i horiz) (cons (nth i (nth j (nth k lista))) (proveriHoriz i (1+ j) k lista))))
   ((< i (length lista))(proveriHoriz (1+ i) 0 k lista))
   ((< k (length lista))(proveriNavise 0 horiz)(proveriHoriz 0 0 (1+ k) lista))
   )
  )

(defun diag (i k lista)
    (cond
   ((< i (length lista))
    (setf (nth k horiz) (cons (nth i (nth i (nth k lista))) (proveriHoriz (1+ i) k lista))))
   ((< k (length lista))(proveriHoriz 0 (1+ k) lista))
     )
  (proveriNavise 0 horiz)
  )

(defun vertikalno (i j k lista)
    (cond
   ((< k (length lista))
    (setf (nth j horiz) (cons (nth i (nth j (nth k lista))) (proveriHoriz i j (1+ k) lista))))
   ((< j (length lista))(proveriHoriz i (1+ j) 0 lista))
   ((< i (length lista))(proveriNavise 0 horiz)(proveriHoriz (1+ i) 0 0 lista))
   )
  )

(defun ende (lista)
  (kraj 0 lista)
  (proveriHoriz 0 0 0 lista)
  (vertikalno 0 0 0 lista)
  (diag 0 0 lista)
  (sracunaj (length lista))
  )


(defun kraj (n lista)
  (proveriNavise 0 (nth n lista))
  (if(< (+ 1 n) (length lista))
      (kraj (+ n 1) lista)(sracunaj (length lista)))
 
  )

;;Poziva se za n=0, rekurzivno sa (incf n)
;;skladisti samo indekse na kojima je moguce dodavanje elementa
;;odredi stap koji ima lsobodnih mesta, a funkcija (potez) odredi koja je to slobodna pozicija
(defun novastanja (n lista)
  (if(< n (length lista))
      ;;preko rekurzije samo da se doda funkcija jos jedna, ovako je brze cini mi se
        (dotimes (z (length lista))
          (if(> (length (member '- (nth z (nth n lista)))) 0)
                       (setq mogucaStanja (append mogucaStanja (list (list n z))))
                       )
           )
    )
  ;;dodaj lambda fju za ovo
  (if(< n (- (length lista) 1))(stanja (+ 1 n) lista))
 )

  (defvar tip)
(defvar mogucaStanja)
  (defvar oznake)
    (defvar i)
  (defvar j)
  (defvar lista)
  (defvar brojPoteza)
  (defvar prvi)
  (defvar pts1)
  (defvar pts2)
  (defvar len)
  (defvar drugi)